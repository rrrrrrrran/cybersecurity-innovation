
# SM4-GCM 加密实现（C++/SIMD）

本项目是一个基于 **C++** 和 **Intel SIMD 指令（SSE2）** 的国密算法 **SM4-GCM 模式** 的简洁实现，用于学习、测试或嵌入高性能安全通信系统。

## 特性

- 实现 SM4 加密算法
- 实现 GCM 模式的加解密流程（无认证标签）
- 使用 Intel SIMD `_mm_*` 指令集进行并行处理
- 支持多块数据的加解密
- 提供完整的测试 `main()` 函数

## 编译环境要求

- C++11 或以上
- 支持 SSE2/SSSE3 指令集的编译器（如 `g++`, `clang++`, `MSVC`）
- 建议使用 `g++` 编译：

```bash
g++ -std=c++11 -O3 -march=native -o sm4_gcm SM4.cpp
```

## 文件结构

| 文件名       | 说明                              |
|--------------|-----------------------------------|
| `SM4.cpp` | 主程序，实现 SM4-GCM 的加解密逻辑 |
| `README.md`  | 使用说明文档（当前文件）           |

## 用法

编译后运行程序：

```bash
./sm4_gcm
```

输出示例：

```
密钥:  20 9a 50 ee 40 78 36 fd 12 49 32 f6 9e 7d 49 dc 
IV:   ad 4f 14 f2 44 40 66 d0 6b c4 30 b7 32 3b a1 22
明文[0]: 29 23 be 84 e1 6c d6 ae 52 90 49 f1 f1 bb e9 eb
密文[0]: cd 78 8d a7 b3 31 f4 eb 04 85 bb 3b 0c 72 82 0d
解密[0]: 29 23 be 84 e1 6c d6 ae 52 90 49 f1 f1 bb e9 eb
明文[1]: b3 a6 db 3c 87 0c 3e 99 24 5e 0d 1c 06 b7 47 de
密文[1]: fb 6e 7d 1f 8b 5d 3f 3a 64 e1 c6 cf cd b8 12 f8
解密[1]: b3 a6 db 3c 87 0c 3e 99 24 5e 0d 1c 06 b7 47 de
明文[2]: b3 12 4d c8 43 bb 8b a6 1f 03 5a 7d 09 38 25 1f
密文[2]: b7 05 b2 1b 68 04 0c 7e 40 cb 91 e4 6c a0 40 1d
解密[2]: b3 12 4d c8 43 bb 8b a6 1f 03 5a 7d 09 38 25 1f
明文[3]: 5d d4 cb fc 96 f5 45 3b 13 0d 89 0a 1c db ae 32
密文[3]: 71 ee c0 dd 49 6a 3a 26 6a 50 75 4b 13 80 05 a2
解密[3]: 5d d4 cb fc 96 f5 45 3b 13 0d 89 0a 1c db ae 32
加密耗时: 136 微秒
解密耗时: 120 微秒
```

# 并行优化说明（SIMD 加速）

本项目在实现 SM4-GCM 加解密时，采用了 Intel SIMD 指令集（SSE2/SSSE3）进行向量化处理，显著提升了处理速度。以下是具体的并行机制解析：

## 1. 分组分块处理（Block-Level Parallelism）

GCM 模式是一种基于**计数器（CTR）模式**的分组加密结构，具备天然的并行性。在本实现中：

- 将明文按 128-bit（16 字节）为单位分块；
- 每一块使用独立的计数器块 Counter Block（IV + Counter）加密；
- SM4 加密这些计数器块，作为伪随机序列；
- 最终与明文进行 XOR，生成密文。

由于每个块的加密互不依赖，我们可以在多个加密轮中**同时加密多个 Counter Block**，实现并行加速。

## 2. 利用 Intel SSE 指令并行 SM4 轮函数

项目中已实现的 `SM4_enc()` 函数内部对 SM4 的 32 轮进行了优化：

- 使用 `__m128i` 类型保存 128 位数据；
- 使用 `_mm_xor_si128()`、`_mm_shuffle_epi8()` 等指令实现并行字节操作与轮函数替代；
- 对多个块使用**多个寄存器并行进行轮函数处理**；
- 减少内存访问与分支判断，实现流水线化执行。

虽然标准 SSE 只能处理 128-bit，但我们依然可以在流水线上并行处理多个 block。例如在代码中一次处理 4 个 `__m128i` 明文块：

```cpp
__m128i ctrs[4];   // 四个计数器块
__m128i ks[4];     // 四个加密后的伪随机流
for (int i = 0; i < 4; i++)
    ctrs[i] = increment_counter(base_iv, i);
SM4_enc4(ks, ctrs, round_keys); // 并行加密
for (int i = 0; i < 4; i++)
    ciphers[i] = _mm_xor_si128(ks[i], plaintexts[i]);
```

## 3.延迟加载与预取优化（Memory-Level Parallelism）
为了优化多块加密过程中的内存访问效率，本项目还采用了以下技术：

- 数据预取（_mm_prefetch）：提前加载数据到缓存，减少内存访问延迟；

- 非阻塞写（_mm_stream_si128）：避免缓存污染，提高写入效率；

- 使用对齐内存分配（aligned_alloc()）：确保数据按照 16 字节对齐，提升 SIMD 访问效率。

这些优化手段有效缓解了内存带宽瓶颈，提升了整体加解密吞吐量。
